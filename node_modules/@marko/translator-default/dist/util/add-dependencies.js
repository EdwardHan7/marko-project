"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.default = void 0;var _path = _interopRequireDefault(require("path"));
var _babelUtils = require("@marko/babel-utils");




var _compiler = require("@marko/compiler");
var _magicString = _interopRequireDefault(require("magic-string"));
var _resolveFrom = _interopRequireDefault(require("resolve-from"));var _default =

(entryFile, isHydrate) => {
  const { resolveVirtualDependency, hydrateIncludeImports, hydrateInit } =
  entryFile.markoOpts;
  const program = entryFile.path;
  const shouldIncludeImport = toTestFn(hydrateIncludeImports);
  const resolvedDeps = new Set();
  const body = [];

  if (!isHydrate) {
    scanBrowserDeps(entryFile);
    if (body.length) {
      program.node.body = body.concat(program.node.body);
    }
    return;
  }

  const hydratedTemplates = new Set();
  const watchFiles = new Set();
  let hasComponents = false;
  let splitComponentIndex = 0;

  scanHydrateDeps(entryFile);

  if (hasComponents) {
    const initId = _compiler.types.identifier("init");
    const markoComponentsImport = importPath(
      resolvePath(entryFile, "marko/src/runtime/components/index.js")
    );
    if (splitComponentIndex) {
      markoComponentsImport.specifiers.push(
        _compiler.types.importSpecifier(_compiler.types.identifier("register"), _compiler.types.identifier("register"))
      );
    }

    body.unshift(markoComponentsImport);

    if (hydrateInit) {
      markoComponentsImport.specifiers.push(_compiler.types.importSpecifier(initId, initId));
      body.push(
        _compiler.types.expressionStatement(
          _compiler.types.callExpression(
            initId,
            entryFile.markoOpts.runtimeId ?
            [_compiler.types.stringLiteral(entryFile.markoOpts.runtimeId)] :
            []
          )
        )
      );
    }
  }

  entryFile.metadata.marko.watchFiles = Array.from(watchFiles);
  program.node.body = body;
  program.skip();

  function scanHydrateDeps(file) {
    const meta = file.metadata.marko;
    const resolved = (0, _babelUtils.resolveRelativePath)(entryFile, file.opts.filename);
    if (hydratedTemplates.has(resolved)) return;

    hydratedTemplates.add(resolved);

    if (meta.component) {
      hasComponents = true;

      if (_path.default.basename(meta.component) === _path.default.basename(file.opts.filename)) {
        // Stateful component.
        addDep(resolved);
        return;
      }
    }

    watchFiles.add(file.opts.filename);

    for (const watchFile of meta.watchFiles) {
      watchFiles.add(watchFile);
    }

    scanBrowserDeps(file);

    for (const child of file.path.node.body) {
      if (_compiler.types.isImportDeclaration(child)) {
        const { value } = child.source;
        if (shouldIncludeImport(value)) {
          addDep(resolvePath(file, value));
        }
      }
    }

    for (const tag of meta.tags) {
      if (tag.endsWith(".marko")) {
        if (!hydratedTemplates.has(resolvePath(file, tag))) {
          scanHydrateDeps((0, _babelUtils.loadFileForImport)(file, tag));
        }
      } else {
        const importedTemplates = tryGetTemplateImports(file, tag);
        if (importedTemplates) {
          for (const templateFile of importedTemplates) {
            if (!hydratedTemplates.has(resolvePath(file, templateFile))) {
              scanHydrateDeps((0, _babelUtils.loadFileForImport)(file, templateFile));
            }
          }
        }
      }
    }

    if (meta.component) {
      // Split component
      const splitComponentId = _compiler.types.identifier(
        `component_${splitComponentIndex++}`
      );
      const splitComponentImport = importPath(
        resolvePath(file, meta.component)
      );
      splitComponentImport.specifiers.push(
        _compiler.types.importDefaultSpecifier(splitComponentId)
      );
      body.push(
        splitComponentImport,
        _compiler.types.expressionStatement(
          _compiler.types.callExpression(_compiler.types.identifier("register"), [
          _compiler.types.stringLiteral(meta.id),
          splitComponentId]
          )
        )
      );
    }
  }

  function scanBrowserDeps(file) {
    const { filename, sourceMaps } = file.opts;
    let s;

    for (let dep of file.metadata.marko.deps) {
      if (typeof dep !== "string") {
        const { virtualPath } = dep;
        let { code } = dep;
        let map;

        if (sourceMaps && dep.startPos !== undefined) {
          s = s || new _magicString.default(file.code, { source: filename });
          map = s.snip(dep.startPos, dep.endPos).generateMap({
            source: filename,
            includeContent: true
          });

          if (sourceMaps === "inline" || sourceMaps === "both") {
            code += dep.style ?
            `\n/*# sourceMappingURL=${map.toUrl()}*/` :
            `\n//# sourceMappingURL=${map.toUrl()}`;

            if (sourceMaps === "inline") {
              map = undefined;
            }
          }
        }

        dep = resolveVirtualDependency(filename, {
          map,
          code,
          virtualPath
        });

        if (!dep) {
          continue;
        }
      } else if (dep.startsWith("package:")) {
        continue;
      }

      addDep(resolvePath(file, dep));
    }
  }

  function addDep(resolved) {
    if (resolvedDeps.has(resolved)) return;
    resolvedDeps.add(resolved);
    body.push(importPath(resolved));
  }

  function resolvePath(file, req) {
    return file === entryFile ?
    (0, _babelUtils.resolveRelativePath)(file, req) :
    (0, _babelUtils.resolveRelativePath)(
      entryFile,
      _path.default.join(file.opts.filename, "..", req)
    );
  }

  function importPath(path) {
    return _compiler.types.importDeclaration([], _compiler.types.stringLiteral(path));
  }
};exports.default = _default;

function tryGetTemplateImports(file, rendererRelativePath) {
  const resolvedRendererPath = _path.default.join(
    file.opts.filename,
    "..",
    rendererRelativePath
  );
  let templateImports;

  try {
    for (const statement of (0, _babelUtils.parseStatements)(
      file,
      file.markoOpts.fileSystem.readFileSync(resolvedRendererPath, "utf-8")
    )) {
      if (statement.type === "ImportDeclaration") {
        addImport(statement.source.value);
      } else {
        _compiler.types.traverseFast(statement, (node) => {
          if (
          node.type === "CallExpression" && (
          node.callee.name === "require" ||
          node.callee.type === "MemberExpression" &&
          node.callee.object.type === "Identifier" &&
          node.callee.object.name === "require" &&
          node.callee.property.type === "Identifier" &&
          node.callee.property.name === "resolve") &&
          node.arguments.length === 1 &&
          node.arguments[0].type === "StringLiteral")
          {
            addImport(node.arguments[0].value);
          }
        });
      }
    }
  } catch {

    // Ignore
  }
  return templateImports;

  function addImport(request) {
    if (request.endsWith(".marko")) {
      const resolvedTemplatePath =
      request[0] === "." ?
      _path.default.resolve(resolvedRendererPath, "..", request) :
      _resolveFrom.default.silent(_path.default.dirname(resolvedRendererPath), request);
      if (resolvedTemplatePath) {
        if (templateImports) {
          templateImports.push(resolvedTemplatePath);
        } else {
          templateImports = [resolvedTemplatePath];
        }
      }
    }
  }
}

function toTestFn(val) {
  if (typeof val === "function") {
    return val;
  }

  return val.test.bind(val);
}